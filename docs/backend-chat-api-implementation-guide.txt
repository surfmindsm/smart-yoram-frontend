======================================================================
SMART YORAM 채팅 시스템 백엔드 API 구현 가이드
======================================================================

작성일: 2025-08-10
대상: 백엔드 개발자
프로젝트: Smart Yoram Frontend
Supabase 프로젝트: adzhdsajdamrflvybhxq

======================================================================
1. 현재 상황 요약
======================================================================

1.1 문제 상황
- 프론트엔드에서 채팅 API 호출 시 "404 Not Found" 발생
- 데이터베이스 테이블은 존재하지만 API 엔드포인트가 구현되지 않음
- 현재 Supabase Edge Function으로 임시 우회 중

1.2 데이터베이스 상태
✅ chat_histories 테이블: 존재 (0개 레코드)
✅ chat_messages 테이블: 존재 (0개 레코드)
✅ Supabase 프로젝트: 정상 운영 중

1.3 프론트엔드 상태
✅ API 호출 코드: 구현 완료 (API 명세서에 맞게 수정됨)
✅ UI 컴포넌트: 구현 완료
✅ 에러 처리: 백엔드 API 실패 시 Edge Function 폴백 구현

======================================================================
2. 구현해야 할 API 엔드포인트
======================================================================

BASE_URL: https://api.surfmind-team.com/api/v1

2.1 채팅 히스토리 목록 조회
----------------------------
GET /chat/histories

Query Parameters:
- include_messages (optional, boolean): true시 각 히스토리의 최근 메시지 포함
- limit (optional, integer): 반환할 히스토리 개수 (기본값: 50)
- skip (optional, integer): 건너뛸 히스토리 개수 (기본값: 0)

Response:
{
  "success": true,
  "data": [
    {
      "id": "uuid 또는 integer",
      "title": "최근 4주 연속 주일예배...",
      "agentName": "설교 도우미",
      "isBookmarked": true,
      "messageCount": 8,
      "timestamp": "2025-08-08T10:30:00Z",
      "messages": [  // include_messages=true일 때만
        {
          "id": "uuid",
          "content": "마지막 메시지 내용",
          "role": "assistant",
          "tokensUsed": 25,
          "timestamp": "2025-08-08T10:30:00Z"
        }
      ]
    }
  ]
}

DB 쿼리 예시:
- chat_histories 테이블에서 현재 church_id, user_id에 해당하는 레코드 조회
- created_at DESC 순서로 정렬
- ai_agents 테이블과 JOIN하여 agent 이름 조회

2.2 새 채팅 히스토리 생성
------------------------
POST /chat/histories

Request Body:
{
  "agent_id": "uuid 또는 integer",
  "title": "새 대화"
}

Response:
{
  "success": true,
  "data": {
    "id": "uuid",
    "title": "새 대화",
    "timestamp": "2025-08-08T10:30:00Z",
    "messageCount": 0,
    "isBookmarked": false
  }
}

DB 쿼리 예시:
- chat_histories 테이블에 새 레코드 INSERT
- church_id, user_id는 JWT 토큰에서 추출
- agent_id, title은 요청에서 받음
- created_at, updated_at는 현재 시간

2.3 특정 채팅의 메시지 목록 조회
------------------------------
GET /chat/histories/{historyId}/messages

Response:
{
  "success": true,
  "data": [
    {
      "id": "uuid",
      "content": "안녕하세요",
      "role": "user",
      "tokensUsed": 0,
      "timestamp": "2025-08-08T10:30:00Z"
    },
    {
      "id": "uuid",
      "content": "안녕하세요! 어떻게 도와드릴까요?",
      "role": "assistant", 
      "tokensUsed": 25,
      "timestamp": "2025-08-08T10:30:05Z"
    }
  ]
}

DB 쿼리 예시:
- chat_messages 테이블에서 chat_history_id = {historyId}인 레코드 조회
- created_at ASC 순서로 정렬
- 권한 확인: 해당 chat_history가 현재 사용자의 것인지 검증

2.4 메시지 전송 및 AI 응답 생성 (핵심 API)
----------------------------------------
POST /chat/messages

Request Body:
{
  "chat_history_id": "uuid",
  "agent_id": "uuid",
  "content": "이번 주 결석자 현황을 알려주세요"
}

Response:
{
  "success": true,
  "data": {
    "user_message": {
      "id": "uuid",
      "content": "이번 주 결석자 현황을 알려주세요",
      "role": "user",
      "timestamp": "2025-08-08T10:30:00Z"
    },
    "ai_response": {
      "id": "uuid", 
      "content": "이번 주 결석자는 총 5명입니다...",
      "role": "assistant",
      "tokensUsed": 150,
      "dataSources": ["church_members", "attendance_records"],
      "timestamp": "2025-08-08T10:30:05Z"
    }
  }
}

처리 로직:
1. 사용자 메시지를 chat_messages 테이블에 INSERT
2. AI 에이전트 정보를 기반으로 시스템 프롬프트 구성
3. OpenAI GPT API 호출 (교회의 GPT API 키 사용)
4. AI 응답을 chat_messages 테이블에 INSERT (토큰 사용량 포함)
5. chat_histories 테이블의 message_count 증가 (+2)
6. 교회의 토큰 사용량 업데이트 (churches.current_month_tokens)

2.5 채팅 히스토리 수정
--------------------
PUT /chat/histories/{historyId}

Request Body:
{
  "title": "새로운 제목",
  "isBookmarked": true
}

Response:
{
  "success": true,
  "data": {
    "id": "uuid",
    "title": "새로운 제목",
    "isBookmarked": true,
    "updated_at": "2025-08-08T10:30:00Z"
  }
}

2.6 채팅 히스토리 삭제
--------------------
DELETE /chat/histories/{historyId}

Response:
{
  "success": true,
  "message": "채팅 히스토리가 삭제되었습니다."
}

처리 로직:
1. chat_messages에서 해당 chat_history_id의 모든 메시지 삭제
2. chat_histories에서 해당 레코드 삭제
3. 권한 확인 필수

======================================================================
3. 데이터베이스 스키마
======================================================================

3.1 chat_histories 테이블
------------------------
컬럼명               타입                설명
id                  SERIAL PRIMARY KEY  채팅 히스토리 ID
church_id           INTEGER NOT NULL    교회 ID (FK: churches.id)
user_id             INTEGER NOT NULL    사용자 ID (FK: users.id)
agent_id            INTEGER NOT NULL    AI 에이전트 ID (FK: ai_agents.id)
title               VARCHAR NOT NULL    채팅 제목
is_bookmarked       BOOLEAN DEFAULT false  북마크 여부
message_count       INTEGER DEFAULT 0   메시지 개수
created_at          TIMESTAMPTZ DEFAULT now()
updated_at          TIMESTAMPTZ

3.2 chat_messages 테이블
-----------------------
컬럼명               타입                설명
id                  SERIAL PRIMARY KEY  메시지 ID
chat_history_id     INTEGER NOT NULL    채팅 히스토리 ID (FK: chat_histories.id)
content             TEXT NOT NULL       메시지 내용
role                VARCHAR NOT NULL    메시지 역할 ('user' | 'assistant')
tokens_used         INTEGER             사용된 토큰 수 (AI 응답시에만)
created_at          TIMESTAMPTZ DEFAULT now()

======================================================================
4. GPT API 연동 가이드
======================================================================

4.1 API 키 관리
--------------
- churches 테이블의 gpt_api_key 컬럼에서 교회별 API 키 조회
- 환경변수 대신 DB에서 동적으로 API 키 로드
- API 키가 없으면 기본 키 사용 또는 에러 반환

4.2 시스템 프롬프트 구성
---------------------
예시:
"당신은 [교회명]의 사역을 돕는 AI 교역자입니다. 
한국어로 친근하고 도움이 되는 답변을 제공해주세요.
에이전트 역할: [에이전트 설명]"

4.3 토큰 사용량 추적
-----------------
- GPT API 응답에서 usage.total_tokens 값 추출
- chat_messages.tokens_used에 저장
- churches.current_month_tokens에 누적
- churches.monthly_token_limit과 비교하여 제한 확인

======================================================================
5. 인증 및 권한 관리
======================================================================

5.1 JWT 토큰 검증
----------------
- Authorization 헤더에서 Bearer 토큰 추출
- JWT 토큰 검증 후 user_id, church_id 추출
- 모든 API에서 인증 필수

5.2 권한 확인
------------
- 채팅 히스토리 접근: 해당 히스토리의 church_id, user_id가 현재 사용자와 일치
- 메시지 접근: 해당 메시지의 채팅 히스토리 소유자와 일치
- AI 에이전트 사용: 해당 에이전트가 현재 교회에서 활성화되어 있는지 확인

======================================================================
6. 에러 처리
======================================================================

6.1 HTTP 상태 코드
-----------------
200: 성공
400: 잘못된 요청 (필수 필드 누락, 데이터 형식 오류)
401: 인증 실패
403: 권한 없음
404: 리소스 없음 (채팅 히스토리, 메시지 등)
500: 서버 내부 오류

6.2 에러 응답 형식
-----------------
{
  "success": false,
  "error": "ERROR_CODE",
  "message": "사용자에게 표시할 메시지",
  "details": "개발자용 상세 정보"
}

6.3 주요 에러 케이스
-----------------
- GPT API 호출 실패 → 토큰 부족, API 키 오류 등
- 토큰 한도 초과 → monthly_token_limit 체크
- 권한 없는 채팅 접근 → 다른 교회/사용자의 채팅
- 존재하지 않는 에이전트 → 비활성화되거나 삭제된 에이전트

======================================================================
7. 성능 최적화 제안
======================================================================

7.1 데이터베이스 인덱스
---------------------
- chat_histories: (church_id, user_id, created_at DESC)
- chat_messages: (chat_history_id, created_at ASC)

7.2 캐싱 전략
------------
- 채팅 히스토리 목록: Redis 캐싱 (5분)
- AI 에이전트 정보: 메모리 캐싱
- 교회 설정 정보: 메모리 캐싱

======================================================================
8. 테스트 가이드
======================================================================

8.1 프론트엔드 테스트 시나리오
----------------------------
1. 새 채팅 시작 → POST /chat/histories
2. 메시지 전송 → POST /chat/messages
3. 채팅 목록 조회 → GET /chat/histories
4. 메시지 히스토리 조회 → GET /chat/histories/{id}/messages
5. 채팅 제목 수정 → PUT /chat/histories/{id}
6. 채팅 삭제 → DELETE /chat/histories/{id}

8.2 테스트용 cURL 명령어
-----------------------
# 채팅 히스토리 조회
curl -X GET "https://api.surfmind-team.com/api/v1/chat/histories" \
  -H "Authorization: Bearer {JWT_TOKEN}"

# 새 채팅 생성
curl -X POST "https://api.surfmind-team.com/api/v1/chat/histories" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer {JWT_TOKEN}" \
  -d '{"agent_id": 1, "title": "테스트 대화"}'

# 메시지 전송
curl -X POST "https://api.surfmind-team.com/api/v1/chat/messages" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer {JWT_TOKEN}" \
  -d '{"chat_history_id": 1, "agent_id": 1, "content": "안녕하세요"}'

======================================================================
9. 현재 임시 구현 상태
======================================================================

9.1 Supabase Edge Function (임시 솔루션)
--------------------------------------
- 함수명: chat-gpt
- 기능: GPT API 호출 + 기본적인 DB 저장
- 제한사항: 백엔드 API 없이 직접 DB 접근

9.2 프론트엔드 폴백 로직
---------------------
- 백엔드 API 호출 실패 시 자동으로 Edge Function 호출
- API 구현 완료 후 Edge Function은 비활성화 예정

======================================================================
10. 구현 우선순위
======================================================================

우선순위 1 (긴급):
- POST /chat/messages (메시지 전송 및 AI 응답)
- GET /chat/histories (채팅 목록)

우선순위 2 (중요):
- POST /chat/histories (새 채팅 생성)
- GET /chat/histories/{id}/messages (메시지 히스토리)

우선순위 3 (보통):
- PUT /chat/histories/{id} (제목 수정, 북마크)
- DELETE /chat/histories/{id} (채팅 삭제)

======================================================================
11. 연락처 및 참고 자료
======================================================================

Supabase 프로젝트: https://adzhdsajdamrflvybhxq.supabase.co
API 명세서: /docs/backend-api-specification.md
프론트엔드 코드: /admin-dashboard/src/services/api.ts

질문이나 추가 정보가 필요한 경우 프론트엔드 개발팀에 문의바랍니다.

======================================================================
